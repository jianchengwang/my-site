__NUXT_JSONP__("/tech/es6", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_,$,aa,ab,ac,ad,ae,af,ag,ah,ai,aj,ak,al,am,an,ao,ap,aq,ar,as,at,au,av,aw,ax,ay,az,aA,aB,aC,aD,aE,aF,aG,aH,aI,aJ,aK,aL,aM,aN,aO,aP,aQ,aR,aS,aT,aU,aV,aW,aX,aY,aZ,a_,a$,ba,bb,bc,bd,be,bf,bg,bh,bi,bj,bk,bl,bm,bn,bo,bp,bq,br,bs,bt,bu,bv,bw,bx,by,bz,bA,bB,bC,bD,bE,bF,bG){aQ.id=aR;aQ.depth=J;aQ.text=aS;aQ.level=x;aQ.children=[];aQ.no="2.1";aT.id=aU;aT.depth=J;aT.text=aV;aT.level=x;aT.children=[];aT.no="2.2";aW.id=ai;aW.depth=J;aW.text=ai;aW.level=x;aW.children=[];aW.no="2.3";aX.id=am;aX.depth=J;aX.text=am;aX.level=x;aX.children=[];aX.no="2.4";a_.id=an;a_.depth=J;a_.text=an;a_.level=x;a_.children=[];a_.no="3.1";a$.id=ao;a$.depth=J;a$.text=ao;a$.level=x;a$.children=[];a$.no="3.2";ba.id=bb;ba.depth=J;ba.text=bc;ba.level=x;ba.children=[];ba.no="5.1";bd.id=ar;bd.depth=J;bd.text=ar;bd.level=x;bd.children=[];bd.no="5.2";be.id=bf;be.depth=J;be.text=bg;be.level=x;be.children=[];be.no="5.3";bh.id=bi;bh.depth=J;bh.text=bj;bh.level=x;bh.children=[];bh.no="5.4";bk.id=bl;bk.depth=J;bk.text=bm;bk.level=x;bk.children=[];bk.no="5.5";bn.id=as;bn.depth=J;bn.text=as;bn.level=x;bn.children=[];bn.no="5.6";return {data:[{doc:{slug:al,description:"现代浏览器基本都支持 ES6 大部分特性，如果你想知道有哪些浏览器支持 ES6 的特性，请戳\nNode 是 JavaScript 的服务器运行环境（runtime）。它对 ES6 的支持度更高。除了那些默认打开的功能，还有一些语法功能已经实现了，但是默认没有打开。",title:al,createdAt:"2019-12-09T00:00:00.000Z",categories:["web","js"],tags:[al],toc:[{id:aO,depth:x,text:aP,level:$,no:$,children:[]},{id:ah,depth:x,text:ah,level:$,no:x,children:[aQ,aT,aW,aX]},aQ,aT,aW,aX,{id:aY,depth:x,text:aZ,level:$,no:J,children:[a_,a$]},a_,a$,{id:ap,depth:x,text:ap,level:$,no:4,children:[]},{id:aq,depth:x,text:aq,level:$,no:5,children:[ba,bd,be,bh,bk,bn]},ba,bd,be,bh,bk,bn,{id:at,depth:x,text:at,level:$,no:6,children:[]}],body:{type:bo,children:[{type:b,tag:h,props:{},children:[{type:a,value:bp},{type:b,tag:g,props:{},children:[{type:a,value:aj}]},{type:a,value:bq},{type:b,tag:g,props:{},children:[{type:a,value:aj}]},{type:a,value:br},{type:b,tag:t,props:{href:bs,rel:[T,U,V],target:W},children:[{type:a,value:aC}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:b,tag:g,props:{},children:[{type:a,value:bt}]},{type:a,value:bu}]},{type:a,value:e},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,"language-shell"]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"node --v8-options "},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:"|"}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:"grep"}]},{type:a,value:" harmony\n"}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"而且我们还有"},{type:b,tag:g,props:{},children:[{type:a,value:"Babel"}]},{type:a,value:" 转码器，可以很方便地将 "},{type:b,tag:g,props:{},children:[{type:a,value:aj}]},{type:a,value:" 代码转换成 "},{type:b,tag:g,props:{},children:[{type:a,value:"ES5"}]},{type:a,value:" 代码。"}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"有兴趣可以看下阮一峰大佬的ECMAScript6入门，内容很详细明了，最底下有相关链接，我这里只是简单的学习记录，方便后面查阅。"}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"今天就写了箭头函数相关的，后面看到segmentfault一篇博客，感觉总结挺好的，就厚颜无耻地拷贝过来了，改了点东东，原文"},{type:b,tag:t,props:{href:bv,rel:[T,U,V],target:W},children:[{type:a,value:aC}]}]},{type:a,value:e},{type:b,tag:ad,props:{id:aO},children:[{type:b,tag:t,props:{href:"#arrow-function-%E3%80%8B",ariaHidden:y,tabIndex:z},children:[{type:b,tag:c,props:{className:[A,B]},children:[]}]},{type:a,value:aP}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"箭头函数 "},{type:b,tag:g,props:{},children:[{type:a,value:L}]},{type:a,value:" ，首先可以去除 "},{type:b,tag:g,props:{},children:[{type:a,value:j}]},{type:a,value:" 标识符，让我们的代码更简洁明了，只关注参数跟函数逻辑代码"}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,ae]},children:[{type:b,tag:g,props:{},children:[{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:M}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,K,j]},children:[{type:a,value:bw}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:P}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,Q]},children:[{type:a,value:E},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:w}]},{type:a,value:aD}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:G}]},{type:a,value:Z},{type:b,tag:c,props:{className:[d,s,aE]},children:[{type:a,value:aF}]},{type:a,value:aG},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:aa}]},{type:a,value:aD},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:ab}]},{type:a,value:e},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:H}]},{type:a,value:aH},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:M}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,K,j]},children:[{type:a,value:bx}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:P}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,Q]},children:[{type:a,value:E},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:w}]},{type:a,value:aD}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,R,o]},children:[{type:a,value:L}]},{type:a,value:aG},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:aa}]},{type:a,value:" name\n"},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:M}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,K,j]},children:[{type:a,value:by}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:P}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,Q]},children:[{type:a,value:E}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,R,o]},children:[{type:a,value:L}]},{type:a,value:aG},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:aa}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,I]},children:[{type:a,value:ac}]},{type:a,value:aH},{type:b,tag:c,props:{className:[d,C,S]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,D,j,v]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:bw}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,I]},children:[{type:a,value:aI}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:w}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,I]},children:[{type:a,value:ac}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:a,value:e},{type:b,tag:c,props:{className:[d,C,S]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,D,j,v]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:bx}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,I]},children:[{type:a,value:aI}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:w}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,I]},children:[{type:a,value:ac}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:a,value:e},{type:b,tag:c,props:{className:[d,C,S]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,D,j,v]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:by}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,I]},children:[{type:a,value:aI}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:a,value:e}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"同样，我们之前如果函数里面如果嵌套函数的话，那么"},{type:b,tag:g,props:{},children:[{type:a,value:F}]},{type:a,value:" 指向便需要注意，"},{type:b,tag:g,props:{},children:[{type:a,value:"ok, no bb, show you my code"}]}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,ae]},children:[{type:b,tag:g,props:{},children:[{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:M}]},{type:a,value:" deliveryBody "},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:P}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:G}]},{type:a,value:au},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:N}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,I]},children:[{type:a,value:ac}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:w}]},{type:a,value:av},{type:b,tag:c,props:{className:[d,K,j]},children:[{type:a,value:X}]},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:N}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,Q]},children:[{type:a,value:E},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:w}]},{type:a,value:aw}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:G}]},{type:a,value:af},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:ax}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:a,value:E},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:a,value:Z},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:H}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:w}]},{type:a,value:ay},{type:b,tag:c,props:{className:[d,K,j]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:N}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:G}]},{type:a,value:"\n\n        "},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:M}]},{type:a,value:" that "},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:P}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:F}]},{type:a,value:"\n        \n        "},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:F}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,D,j,v]},children:[{type:a,value:X}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,I]},children:[{type:a,value:az}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:w}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,Q]},children:[{type:a,value:E}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:G}]},{type:a,value:"\n            "},{type:b,tag:c,props:{className:[d,C,S]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,D,j,v]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:a,value:aA},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:aa}]},{type:a,value:" that"},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,v]},children:[{type:a,value:aB}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:a,value:af},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:H}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:a,value:Z},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:H}]},{type:a,value:e},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:H}]},{type:a,value:"\n\ndeliveryBody"},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,D,j,v]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:a,value:e}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"使用箭头函数，我们可以对上面代码做些调整"}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,ae]},children:[{type:b,tag:g,props:{},children:[{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:M}]},{type:a,value:aJ},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:P}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:G}]},{type:a,value:au},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:N}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,I]},children:[{type:a,value:ac}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:w}]},{type:a,value:av},{type:b,tag:c,props:{className:[d,K,j]},children:[{type:a,value:X}]},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:N}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,Q]},children:[{type:a,value:E},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:w}]},{type:a,value:aw}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:G}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:ax}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:a,value:E},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:H}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:w}]},{type:a,value:ay},{type:b,tag:c,props:{className:[d,K,j]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:N}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:j}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:G}]},{type:a,value:af},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:F}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,D,j,v]},children:[{type:a,value:X}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,I]},children:[{type:a,value:az}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:w}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,Q]},children:[{type:a,value:E}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,R,o]},children:[{type:a,value:L}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,C,S]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,D,j,v]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:a,value:aA},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:aa}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:F}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,v]},children:[{type:a,value:aB}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:a,value:Z},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:H}]},{type:a,value:aK},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:H}]},{type:a,value:aL},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,D,j,v]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:a,value:e}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"有的人可能会问，你扯淡半天，箭头函数那么好用，为什么对象里面的"},{type:b,tag:g,props:{},children:[{type:a,value:X}]},{type:a,value:"，"},{type:b,tag:g,props:{},children:[{type:a,value:Y}]},{type:a,value:"函数不用箭头函数来表示呢，写成如下形式"}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,ae]},children:[{type:b,tag:g,props:{},children:[{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:M}]},{type:a,value:aJ},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:P}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:G}]},{type:a,value:au},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:N}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,I]},children:[{type:a,value:ac}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:w}]},{type:a,value:av},{type:b,tag:c,props:{className:[d,K,j]},children:[{type:a,value:X}]},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:N}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,Q]},children:[{type:a,value:E},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:w}]},{type:a,value:aw}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,R,o]},children:[{type:a,value:L}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:ax}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:a,value:E},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:w}]},{type:a,value:ay},{type:b,tag:c,props:{className:[d,K,j]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:N}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,R,o]},children:[{type:a,value:L}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:G}]},{type:a,value:af},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:F}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,D,j,v]},children:[{type:a,value:X}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,I]},children:[{type:a,value:az}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:w}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,Q]},children:[{type:a,value:E}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,R,o]},children:[{type:a,value:L}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,C,S]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,D,j,v]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:a,value:aA},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:aa}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:F}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,v]},children:[{type:a,value:aB}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:a,value:Z},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:H}]},{type:a,value:aK},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:H}]},{type:a,value:aL},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,D,j,v]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:a,value:e}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"你可以尝试一下，这样写，会提示"},{type:b,tag:g,props:{},children:[{type:a,value:"TypeError: this.handleMessage is not a function"}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"具体可以看下 stackoverflow 上面的"},{type:b,tag:t,props:{href:"https:\u002F\u002Fstackoverflow.com\u002Fquestions\u002F31095710\u002Fmethods-in-es6-objects-using-arrow-functions",rel:[T,U,V],target:W},children:[{type:a,value:"回答"}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"Arrow functions are not designed to be used in every situation merely as a shorter version of old-fashioned functions. They are not intended to replace function syntax using the "},{type:b,tag:g,props:{},children:[{type:a,value:j}]},{type:a,value:" keyword. The most common use case for arrow functions is as short \"lambdas\" which do not redefine "},{type:b,tag:g,props:{},children:[{type:a,value:F}]},{type:a,value:", often used when passing a function as a callback to some function."}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"Arrow functions cannot be used to write object methods because, as you have found, since arrow functions close over the "},{type:b,tag:g,props:{},children:[{type:a,value:F}]},{type:a,value:" of the lexically enclosing context, the "},{type:b,tag:g,props:{},children:[{type:a,value:F}]},{type:a,value:" within the arrow is the one that was current where you defined the object. Which is to say:"}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"翻译过来就是说，箭头函数并不是设计用于所有情况，而仅仅是作为老式函数的较短版本。它们不打算使用function关键字替换函数语法。箭头函数最常见的用例是短的“lambdas”，它不重新定义这个函数，通常在将函数作为回调传递给某个函数时使用。箭头函数不能用于编写对象方法，因为正如您所发现的，由于箭头函数在词法封闭上下文的this上关闭，箭头内的this就是您定义objec的当前位置"}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,ae]},children:[{type:b,tag:g,props:{},children:[{type:b,tag:c,props:{className:[d,ag]},children:[{type:a,value:"\u002F\u002F Whatever `this` is here..."}]},{type:a,value:e},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:M}]},{type:a,value:aJ},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:P}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:G}]},{type:a,value:au},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:N}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,I]},children:[{type:a,value:ac}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:w}]},{type:a,value:av},{type:b,tag:c,props:{className:[d,K,j]},children:[{type:a,value:X}]},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:N}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,Q]},children:[{type:a,value:E},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:w}]},{type:a,value:aw}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,R,o]},children:[{type:a,value:L}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:ax}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:a,value:E},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:w}]},{type:a,value:ay},{type:b,tag:c,props:{className:[d,K,j]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:N}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,R,o]},children:[{type:a,value:L}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:G}]},{type:a,value:af},{type:b,tag:c,props:{className:[d,ag]},children:[{type:a,value:"\u002F\u002F ...is what `this` is here."}]},{type:a,value:af},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:F}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,D,j,v]},children:[{type:a,value:X}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,I]},children:[{type:a,value:az}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:w}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,Q]},children:[{type:a,value:E}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,R,o]},children:[{type:a,value:L}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,C,S]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,D,j,v]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:a,value:aA},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:aa}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:F}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,v]},children:[{type:a,value:aB}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:a,value:Z},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:H}]},{type:a,value:aK},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:H}]},{type:a,value:aL},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,D,j,v]},children:[{type:a,value:Y}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:a,value:e}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"也正因为箭头函数没有自己的"},{type:b,tag:g,props:{},children:[{type:a,value:F}]},{type:a,value:"导致内部的"},{type:b,tag:g,props:{},children:[{type:a,value:F}]},{type:a,value:"就是外层代码块的"},{type:b,tag:g,props:{},children:[{type:a,value:F}]},{type:a,value:"，所以就不能用作构造函数，也不能使用 "},{type:b,tag:g,props:{},children:[{type:a,value:bz}]},{type:a,value:" ，"},{type:b,tag:g,props:{},children:[{type:a,value:"yield"}]},{type:a,value:"命令等，并且不能使用 "},{type:b,tag:g,props:{},children:[{type:a,value:aM}]},{type:a,value:" 对象，如下都会报错，"}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,ae]},children:[{type:b,tag:g,props:{},children:[{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:M}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,K,j]},children:[{type:a,value:ak}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:P}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,R,o]},children:[{type:a,value:L}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:G}]},{type:b,tag:c,props:{className:[d,s,aE]},children:[{type:a,value:aF}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,bA]},children:[{type:a,value:bB}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:ab}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:H}]},{type:a,value:e},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:ak}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:ab}]},{type:b,tag:c,props:{className:[d,ag]},children:[{type:a,value:"\u002F\u002F1"}]},{type:a,value:e},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:M}]},{type:a,value:" obj "},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:P}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:bz}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,S]},children:[{type:a,value:ak}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:ab}]},{type:b,tag:c,props:{className:[d,ag]},children:[{type:a,value:"\u002F\u002FUncaught TypeError: foo is not a constructor"}]},{type:a,value:aH},{type:b,tag:c,props:{className:[d,ag]},children:[{type:a,value:"\u002F\u002F 下面这个例子要在浏览器环境下，在node环境下，因为有全局的arguments所以不会报错"}]},{type:a,value:e},{type:b,tag:c,props:{className:[d,C,S]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,D,j,v]},children:[{type:a,value:_}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:a,value:aM},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:a,value:e},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:M}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,K,j]},children:[{type:a,value:ak}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,o]},children:[{type:a,value:P}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,R,o]},children:[{type:a,value:L}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:G}]},{type:a,value:Z},{type:b,tag:c,props:{className:[d,C,S]},children:[{type:a,value:C}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:u}]},{type:b,tag:c,props:{className:[d,D,j,v]},children:[{type:a,value:"log"}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:a,value:aM},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:ab}]},{type:b,tag:c,props:{className:[d,ag]},children:[{type:a,value:"\u002F\u002FUncaught ReferenceError: arguments is not defined"}]},{type:a,value:Z},{type:b,tag:c,props:{className:[d,s,aE]},children:[{type:a,value:aF}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,bA]},children:[{type:a,value:bB}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:ab}]},{type:a,value:e},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:H}]},{type:a,value:e},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:ak}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:p}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:q}]},{type:b,tag:c,props:{className:[d,f]},children:[{type:a,value:ab}]},{type:a,value:e}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"所以，箭头函数最常用于回调函数，不要在对象中定义箭头函数。"}]},{type:a,value:e},{type:b,tag:ad,props:{id:ah},children:[{type:b,tag:t,props:{href:"#class",ariaHidden:y,tabIndex:z},children:[{type:b,tag:c,props:{className:[A,B]},children:[]}]},{type:a,value:ah}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"盼星星盼月亮，终于盼来了 JS 的继承。但是 ES6 中的继承和已经很完善的 ES5 中流行的继承库，到底有多少差异？"}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"先来看一个例子："}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"\u002F\u002F定义类\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n  \u002F\u002F 注意函数构造的方式\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n}\nvar p1 = new Point(5, 5);\np1.toString(); \u002F\u002F\"(5, 5)\"\n\ntypeof Point \u002F\u002F function\np1.constructor == Point \u002F\u002Ftrue\n"}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"直接使用 class 关键字，constructor 作为构造方法，函数可以直接 "},{type:b,tag:g,props:{},children:[{type:a,value:"toString(){}"}]},{type:a,value:" 的方式。"}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"但是，class 的本质仍然是函数，是构造函数的另外一种写法。既然 class 的本质是函数，那么必不可少的一些 proto，prototype 方法也是存在的。"}]},{type:a,value:e},{type:b,tag:O,props:{id:aR},children:[{type:b,tag:t,props:{href:"#%E5%85%B3%E4%BA%8E-class-%E7%9A%84%E7%BB%A7%E6%89%BF",ariaHidden:y,tabIndex:z},children:[{type:b,tag:c,props:{className:[A,B]},children:[]}]},{type:a,value:aS}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"通过关键字 extends 可以实现 class 的继承，"}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"class Square extends Point{\n  constructor(x){\n    super(x, x);\n  }\n  toString(){\n    return super.toString() + 'Square!';\n  }\n}\nvar s1 = new Square(4);\ns1.toString(); \u002F\u002F\"(4, 4)Square!\"\ns1 instanceof Point \u002F\u002F true\ns1 instanceof Square \u002F\u002F true\n"}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"既然说到了继承，对 es5 中继承了解到小伙伴，肯定会疑惑关于 class 中的 proto 和 prototype 是一个什么样的关系。"}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"子类的 proto 指向父类，子类的 prototype 的 proto 指向父类的 prototype，这和 ES5 并没有区别。"}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"Square.__proto__ === Point\n\u002F\u002F true\nSquare.prototype.__proto__ === Point.prototype\n\u002F\u002F true\n"}]}]}]},{type:a,value:e},{type:b,tag:O,props:{id:aU},children:[{type:b,tag:t,props:{href:"#super-%E5%85%B3%E9%94%AE%E5%AD%97",ariaHidden:y,tabIndex:z},children:[{type:b,tag:c,props:{className:[A,B]},children:[]}]},{type:a,value:aV}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"在 Java 等语言中，是有 super 继承父类函数，JS 中更加灵活，可以用作父类的构造函数，又可以用作对象。"}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"子类的 constructor 必须要调用 super 方法，且只能在 constructor 方法中调用，其他地方调用会报错。"}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"class A {\n  constructor(a){\n    this.x = a;\n  }\n}\nA.prototype.y = 2;\nclass B extends A{\n  constructor(a){\n    super();\n  }\n  getY(){\n    super() \u002F\u002F 报错\n    return super.y\n  }\n}\n"}]}]}]},{type:a,value:e},{type:b,tag:O,props:{id:ai},children:[{type:b,tag:t,props:{href:"#%E5%8E%9F%E7%94%9F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF",ariaHidden:y,tabIndex:z},children:[{type:b,tag:c,props:{className:[A,B]},children:[]}]},{type:a,value:ai}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"对于一些原生的构造函数，比如 Array，Error，Object，String 等，在 ES5 是无法通过 "},{type:b,tag:g,props:{},children:[{type:a,value:"Object.create"}]},{type:a,value:" 方法实现原生函数的内部属性，原生函数内部的 this 无法绑定，内部属性获得不了。"},{type:b,tag:t,props:{href:"http:\u002F\u002Fes6.ruanyifeng.com\u002F#docs\u002Fclass#",rel:[T,U,V],target:W},children:[{type:a,value:ai}]},{type:a,value:bC}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"ES6 的 class 可以解决这个问题。"}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"class MyArray extends Array {\n  constructor(...args) {\n    super(...args);\n  }\n}\n\nvar arr = new MyArray();\narr[0] = 12;\narr.length \u002F\u002F 1\n\narr.length = 0;\narr[0] \u002F\u002F undefined\n"}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"extends 关键字不仅可以用来继承类，"},{type:b,tag:aN,props:{},children:[{type:a,value:"还能用来继承原生的构造函数"}]},{type:a,value:"，在原生函数的基础上，自定义自己的函数。"}]},{type:a,value:e},{type:b,tag:O,props:{id:am},children:[{type:b,tag:t,props:{href:"#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95",ariaHidden:y,tabIndex:z},children:[{type:b,tag:c,props:{className:[A,B]},children:[]}]},{type:a,value:am}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"ES6 支持 static 关键字，该关键字定义的方法，不会被实例继承，但可以被子类继承："}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"class A{\n  static add(x, y){\n    return x + y;\n }\n}\nA.add(1, 2);\nvar a = new A();\na.add()\u002F\u002F error\nclass B extends A{}\nB.add(2, 2)\u002F\u002F 4 \n"}]}]}]},{type:a,value:e},{type:b,tag:ad,props:{id:aY},children:[{type:b,tag:t,props:{href:"#module",ariaHidden:y,tabIndex:z},children:[{type:b,tag:c,props:{className:[A,B]},children:[]}]},{type:a,value:aZ}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"ES6 之前，JS 一直没有 modules 体系，解决外部包的问题通过 CommonJS 和 AMD 模块加载方案，一个用于服务器，一个用于浏览器。ES6 提出的 modules （import／export）方案完全可以取代 CommonJS 和 AMD 成为浏览器和服务器通用的模块解决方案。"}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"关于模块，就只有两个命令，import 用于导入其他模块，export 用于输出模块。"}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"\u002F\u002F profile.js\nvar firstName = 'Michael';\nvar lastName = 'Jackson';\nvar year = 1958;\n\nexport {firstName, lastName, year};\n\n\u002F\u002F main.js\nimport {firstName, lastName, year} from '.\u002Fprofile';\nconsole.log(firstName, lastName) \u002F\u002F Michael Jackson\n"}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"import 加载的模块可以只加载用到的，但是必须使用同名的原则，可以用 as 来解决名字问题，同样，as 也可以解决 export 问题："}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"\u002F\u002Fmain.js\nimport { lastName as surname } from '.\u002Fprofile';\nconsole.log(surname); \u002F\u002F Jackson\n\n\u002F\u002Fprofile.js\nexport {firstName as name}\n"}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"export 可以输出的内容很多，包括变量、函数、类，貌似都可以输出，还可以借助 export default 来加载默认输出。"}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"\u002F\u002Fdefault.js\nfunction add(a, b){\n  return a + b;\n}\nexport default add;\n\u002F\u002F 实际上\nexport {add as default};\n\n\u002F\u002F main.js\nimport add from '.\u002Fdefault'\n\u002F\u002F实际上 add 名字可以随便起\nimport {default as add} from '.\u002Fdefault'\n"}]}]}]},{type:a,value:e},{type:b,tag:O,props:{id:an},children:[{type:b,tag:t,props:{href:"#%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%AE%9E%E8%B4%A8",ariaHidden:y,tabIndex:z},children:[{type:b,tag:c,props:{className:[A,B]},children:[]}]},{type:a,value:an}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"这部分 "},{type:b,tag:t,props:{href:"http:\u002F\u002Fes6.ruanyifeng.com\u002F#docs\u002Fmodule#ES6",rel:[T,U,V],target:W},children:[{type:a,value:"ES6模块加载的实质"}]},{type:a,value:" 完全只能参考了，因为对模块加载用的不多，没有一点经验，但是看到作者提到了拷贝和引用，感觉逼格很高的样子。"}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。"}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"比如一个 CommonJS 加载的例子："}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"\u002F\u002F lib.js\nvar counter = 3;\nfunction incCounter() {\n  counter++;\n}\nmodule.exports = {\n  counter: counter,\n  incCounter: incCounter,\n};\n\n\u002F\u002F main.js\nvar mod = require('.\u002Flib');\n\nconsole.log(mod.counter);  \u002F\u002F 3\nmod.incCounter();\nconsole.log(mod.counter); \u002F\u002F 3\n"}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"这个值会被 mod 缓存，而取不到原始的值。"}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"ES6 中不一样，它只是生成一个引用，当真正需要的时候，才会到模块里去取值，"}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"\u002F\u002F lib.js\nexport let counter = 3;\nexport function incCounter() {\n  counter++;\n}\n\n\u002F\u002F main.js\nimport { counter, incCounter } from '.\u002Flib';\nconsole.log(counter); \u002F\u002F 3\nincCounter();\nconsole.log(counter); \u002F\u002F 4\n"}]}]}]},{type:a,value:e},{type:b,tag:O,props:{id:ao},children:[{type:b,tag:t,props:{href:"#%E5%BE%AA%E7%8E%AF%E5%8A%A0%E8%BD%BD",ariaHidden:y,tabIndex:z},children:[{type:b,tag:c,props:{className:[A,B]},children:[]}]},{type:a,value:ao}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"循环加载也比较有意思，经常能看到 nodejs 中出现加载同一个模块，而循环加载却不常见，nodejs 使用 CommonJS 模块机制，CommonJS 的循环加载采用的是加载多少，输出多少，就像是我们平时打了断点一样，会跳到另外一个文件，执行完在跳回来。"}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"\u002F\u002Fa.js\nexports.done = '1';\nvar a = require('.\u002Fb.js');\nconsole.log('half a=%s', a);\nexports.done = '3';\nconsole.log('done a');\n\n\u002F\u002Fb.js\nexports.done = '2';\nvar b = require('.\u002Fa.js');\nconsole.log('half b=%s', b);\nexports.done = '4';\nconsole.log('done b');\n\n\u002F\u002Fmain.js\nvar a = require('.\u002Fa.js');\nvar b = require('.\u002Fb.js');\nconsole.log('all done! a=%s,b=%s',a,b)\n"}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:b,tag:g,props:{},children:[{type:a,value:"node main.js"}]},{type:a,value:" 的结果："}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"half a=2\ndone a\nhalf b=3\ndone b\nall done! a=3,b=4\n"}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"这就是 CommonJS 所谓的循环加载。"}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"而 ES6 采用的加载模式也不一样，因为使用动态引用，必须要开发者保证能 import 到值："}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"\u002F\u002F a.js如下\nimport {bar} from '.\u002Fb.js';\nconsole.log('a.js');\nconsole.log(bar);\nexport let foo = 'foo';\n\n\u002F\u002F b.js\nimport {foo} from '.\u002Fa.js';\nconsole.log('b.js');\nconsole.log(foo);\nexport let bar = 'bar';\n"}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"结果："}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"$ babel-node a.js\nb.js\nundefined\na.js\nbar\n"}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"循环加载稍有不慎，就会 underfined。"}]},{type:a,value:e},{type:b,tag:ad,props:{id:ap},children:[{type:b,tag:t,props:{href:"#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E7%89%88",ariaHidden:y,tabIndex:z},children:[{type:b,tag:c,props:{className:[A,B]},children:[]}]},{type:a,value:ap}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"ES6 在字符串上面可是下了不少功夫，先是解决了字符 unicode 的 bug，增加了一些处理多字节字符串 codePointAt 函数，还多了字符串的遍历接口 "},{type:b,tag:g,props:{},children:[{type:a,value:"for...of"}]},{type:a,value:"，这个遍历借口有点仿造 python 的感觉。只要有迭代器功能的对象，都可以用 for...of 来遍历。"}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"ES6 添加了一些有意思的函数，比如 repeat()，前几天比较火的文章‘五道经典的前端面试题’，就有提到一个在字符串上实现原生的重复方法，这里的 repeat 可以直接解决。"}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"关于字符串上的新内容，非常有帮助的还是模版字符串。之前在 js 中跨行的字符串实现起来很别扭，而 python 可以用三个反引号来实现。"}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"ES6 中的模版字符串使用需要注意以下内容："}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"\u002F\u002F ` 可以跨行\nvar html = `\n  \u003Cul\u003E\n    \u003Cli\u003Efirst\u003C\u002Fli\u003E\n    \u003Cli\u003Esecond\u003C\u002Fli\u003E\n  \u003C\u002Ful\u003E`\n\n\u002F\u002F${} 调用变量和函数\nvar name = 'window';\nvar str = `my name is ${name};`;\n\u002F\u002F my name is window;\n\nvar add = (a, b)=\u003E a+b;\nvar str = `2 + 3 = ${add(2,3)}`;\n\u002F\u002F \"2 + 3 = 5\"\n"}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"用过 ejs 、swig 或 hbs 等模版，它们可以嵌入 js 代码，ES6 的模版字符串也可以。使用 \u003C%...%\u003E 放置 JavaScript 代码，使用 \u003C%= ... %\u003E 输出 JavaScript 表达式。"}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"var template = `\n  \u003Cul\u003E\n    \u003C% data.forEach(function(item){ %\u003E\n      \u003Cli\u003E\u003C%= item %\u003E\u003C\u002Fli\u003E\n    \u003C% }) %\u003E\n  \u003C\u002Ful\u003E\n`\n"}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"下面就可以写正则表达式替换掉自定义字符并执行函数："}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"function compile(str){\n  var evalExpr = \u002F\u003C%=(.+?)%\u003E\u002Fg;\n  var expr = \u002F\u003C%([\\s\\S]+?)%\u003E\u002Fg;\n  str = str.replace(evalExpr, '`); \\n  join( $1 ); \\n  join(`')\n    .replace(expr, '`); \\n $1 \\n  join(`');\n  str = 'join(`' + str + '`);';\n  var script = `\n    (function parse(data){\n      var output = \"\";\n\n      function join(html){\n        output += html;\n      }\n\n      ${ str }\n\n      return output;\n    })\n  `\n  return script;\n}\nvar strParse = eval(compile(template));\n\u002F\u002F 使用\nvar html = strParse(['shanghai', 'beijing', 'nanjing']);\n\u002F\u002F  \u003Cul\u003E    \n\u002F\u002F    \u003Cli\u003Eshanghai\u003C\u002Fli\u003E\n\u002F\u002F    \u003Cli\u003Ebeijing\u003C\u002Fli\u003E\n\u002F\u002F    \u003Cli\u003Enanjing\u003C\u002Fli\u003E\n\u002F\u002F  \u003C\u002Ful\u003E\n"}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"通过两次使用字符串模版，并使用 eval 函数，一个 ES6 简易模版就这样完成了。"}]},{type:a,value:e},{type:b,tag:ad,props:{id:aq},children:[{type:b,tag:t,props:{href:"#%E4%B8%80%E4%BA%9B%E5%85%B6%E4%BB%96%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD",ariaHidden:y,tabIndex:z},children:[{type:b,tag:c,props:{className:[A,B]},children:[]}]},{type:a,value:aq}]},{type:a,value:e},{type:b,tag:O,props:{id:bb},children:[{type:b,tag:t,props:{href:"#let-const",ariaHidden:y,tabIndex:z},children:[{type:b,tag:c,props:{className:[A,B]},children:[]}]},{type:a,value:bc}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"ES5 通过 var 来申明变量，ES6 新添 let 和 const，且作用域是 "},{type:b,tag:aN,props:{},children:[{type:a,value:"块级作用域"}]},{type:a,value:bC}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"let 使用和 var 非常类似，"},{type:b,tag:aN,props:{},children:[{type:a,value:"let 不存在变量提升，也不允许重复申明，let 的声明只能在它所在的代码块有效"}]},{type:a,value:"，比如 for 循环，非常适合使用 let："}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"for(let i = 0; i \u003C data.length; i++){\n  console.log(data[i]);\n}\nconsole.log(i); \u002F\u002F error\n"}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"如果用 var 来申明 i，最后不会报错。之前学闭包的时候，有一个利用闭包解决循环的问题，用 let 可以解决:"}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"var a = [];\nfor (let i = 0; i \u003C 10; i++) {\n  a[i] = function () {\n    console.log(i);\n  };\n}\na[6](); \u002F\u002F 6\n"}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"const 就是申明常量用的，一旦申明即被锁定，后面无法更改。"}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"const PI = 3.14;\nPI = 3; \u002F\u002Ferror\n"}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"let 和 const 都是块级作用域，块级作用域可以任意嵌套，且 {} 内定义的变量，外层作用域是无法获得的，且内外层的作用域可以同名。"}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"function fn() {\n  let n = 1;\n  if (true) {\n    let n = 2;\n  }\n  console.log(n); \u002F\u002F 1\n}\n"}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"顶层对象，在浏览器环境指的是"},{type:b,tag:g,props:{},children:[{type:a,value:bD}]},{type:a,value:"对象，在 Node 指的是"},{type:b,tag:g,props:{},children:[{type:a,value:"global"}]},{type:a,value:"对象。ES5 之中，顶层对象的属性与全局变量是等价的。"}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，"},{type:b,tag:g,props:{},children:[{type:a,value:bD}]},{type:a,value:"对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。"}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"ES6 为了改变这一点，一方面规定，为了保持兼容性，"},{type:b,tag:g,props:{},children:[{type:a,value:M}]},{type:a,value:"命令和"},{type:b,tag:g,props:{},children:[{type:a,value:j}]},{type:a,value:"命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，"},{type:b,tag:g,props:{},children:[{type:a,value:"let"}]},{type:a,value:bE},{type:b,tag:g,props:{},children:[{type:a,value:"const"}]},{type:a,value:bE},{type:b,tag:g,props:{},children:[{type:a,value:ah}]},{type:a,value:"命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。"}]},{type:a,value:e},{type:b,tag:O,props:{id:ar},children:[{type:b,tag:t,props:{href:"#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC",ariaHidden:y,tabIndex:z},children:[{type:b,tag:c,props:{className:[A,B]},children:[]}]},{type:a,value:ar}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"解构赋值真的很好用，但是我每次都忘记使用。ES6 解构赋值基本语法 "},{type:b,tag:g,props:{},children:[{type:a,value:"var [a, b, c] = [1, 2, 3];"}]},{type:a,value:"，从数组中取值，并按照先后次序来赋值。如果解构赋值不成功，就会返回 underfined，解构赋值也允许指定默认值："}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"var [a, b] = [1];\nb \u002F\u002F undefined\n\n\u002F\u002F 指定默认值\nvar [a, b = 2] = [1];\nb \u002F\u002F 2\n"}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"除了数组，对象也可以解构赋值，但是数组是有顺序的，而对象没有顺序，如果想要成功赋值，必须与对象属性同名，才能成功赋值，否则返回 underfined："}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"var {a, b} = {a: 1, b: 2};\na \u002F\u002F 1\nb \u002F\u002F 2\n\nvar {a, c} = {a: 1, b: 2};\nc \u002F\u002F undefined\n"}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"字符串的解构赋值比较有意思，既可以把字符串当作可以迭代的数组，又可以当作对象，比如："}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"var [a1,a2,a3,a4,a5] = 'hello';\na2 \u002F\u002F e\n\nvar {length : len} = 'hello';\nlen \u002F\u002F 5\n"}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"函数参数的解构赋值，看一个 forEach 的例子："}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"var data = [[1, 2], [3, 4]];\ndata.forEach(([a, b]) =\u003E console.log(a+b));\n\u002F\u002F 3\n\u002F\u002F 7\n"}]}]}]},{type:a,value:e},{type:b,tag:O,props:{id:bf},children:[{type:b,tag:t,props:{href:"#promise-%E8%A7%A3%E5%86%B3%E5%9B%9E%E6%8E%89",ariaHidden:y,tabIndex:z},children:[{type:b,tag:c,props:{className:[A,B]},children:[]}]},{type:a,value:bg}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"一直以来，回掉问题都是一件令人头疼的事，调试的时候感觉代码跳来跳去，玩着玩着就晕了。ES6 提供 Promise 对象（函数），专门用来处理回掉。"}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"var promise = new Promise(function(resolve, reject) {\n  \u002F\u002F ... some code\n  if (\u002F* 异步操作成功 *\u002F){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n\npromise.then(function(value) {\n  \u002F\u002F success\n}, function(error) {\n  \u002F\u002F failure\n});\n"}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"resolve 和 reject 是两个异步操作调用函数，当异步操作完成时，调用 resolve，error 则调用 reject，这两个函数的功能就是把参数传递给回掉函数。then 函数用来处理成功或失败状态。"}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"function loadImageAsync(url) {\n  var p = new Promise(function(resolve, reject) {\n    var image = new Image();\n\n    image.onload = function() {\n      resolve(image);\n    };\n\n    image.onerror = function() {\n      reject(url);\n    };\n\n    image.src = url;\n  });\n  p.then(function(image){\n    document.body.appendChild(image);\n  }, function(url){\n    throw new Error('Could not load '+ url);\n  })\n}\n\nloadImageAsync('http:\u002F\u002Fyuren.space\u002Fimages\u002Fbg.gif');\n"}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"上面是一个用 Promise 实现的异步加载图片的函数。"}]},{type:a,value:e},{type:b,tag:O,props:{id:bi},children:[{type:b,tag:t,props:{href:"#for-of-%E4%B8%8E-",ariaHidden:y,tabIndex:z},children:[{type:b,tag:c,props:{className:[A,B]},children:[]}]},{type:a,value:bj}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"Python 中有 for in 运算符，ES6 就搞了个 for...of。当使用 for...of 循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是可遍历的，对象、数组、字符串都是可遍历的。"}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"var str = 'hello';\nfor(let i of str){\n  console.log(i);\n}\n\u002F\u002F 'h' 'e' 'l' 'l' 'o'\n"}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:b,tag:g,props:{},children:[{type:a,value:"..."}]},{type:a,value:"也非常好用，可以直接把可遍历对象直接转换成数组："}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"var str = 'hello';\n[...str] \u002F\u002F[\"h\", \"e\", \"l\", \"l\", \"o\"]\n\nlet arr = ['b', 'c'];\n['a', ...arr, 'd'] \n\u002F\u002F ['a', 'b', 'c', 'd']\n"}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"有了 ... 之后，方便对非数组可遍历的对象进行转换，比如 arguments 和 querySelectAll 的结果："}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"[...arguments] \u002F\u002F Array\n\nvar selects = document.querySelectAll('a');\n[...selects] \u002F\u002F Array\n"}]}]}]},{type:a,value:e},{type:b,tag:O,props:{id:bl},children:[{type:b,tag:t,props:{href:"#set-%E9%9B%86%E5%90%88%E5%92%8C-map-%E7%BB%93%E6%9E%84",ariaHidden:y,tabIndex:z},children:[{type:b,tag:c,props:{className:[A,B]},children:[]}]},{type:a,value:bm}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"ES6 新增 Set 集合对象，其实像其他语言早都支持了，不过，吃瓜群众，不觉明厉，以后，再遇到数组去重算法题，就可以："}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"[...(new Set([1, 2, 2, 3]))];\n\u002F\u002F[1, 2, 3]\n"}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"Set 方法分为操作和遍历，操作方法有 add-添加成员， delete-删除成员， has-拥有判断返回布尔值， clear-清空集合。"}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"遍历操作有 keys()，values()，entries()，forEach()，...，for of，map 和 filter 函数也可以用于 Set，不过要进行巧妙操作，先转换成数组，在进行操作："}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"let set = new Set([1,2,3]);\nset = new Set([...set].map(a =\u003E a*2));\n\u002F\u002F Set {2, 4, 6}\n"}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"Map 用来解决对象只接受字符串作为键名，Map 类似于对象，也是键值对集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。"}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"Map 可以通过 [set、 get、 has、 delete] 方法来操作："}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"var m = new Map();\nvar arr = [1, 2];\nm.set(arr, 'array');\nm.get(arr); \u002F\u002F 'array'\n\nm.has(arr) \u002F\u002F true\nm.delete(arr) \u002F\u002F true\nm.has(arr) \u002F\u002F false\n"}]}]}]},{type:a,value:e},{type:b,tag:O,props:{id:as},children:[{type:b,tag:t,props:{href:"#%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4",ariaHidden:y,tabIndex:z},children:[{type:b,tag:c,props:{className:[A,B]},children:[]}]},{type:a,value:as}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"参数默认这个功能使用起来还是比较方便的，以前参数都是通过 || 来实现默认，现在可以使用默认参数。不过这个功能在 Python 等语言中已经是支持的。"}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"\u002F\u002F 以前写代码\nvar sayHello = function(name){\n  var name = name || 'world';\n  console.log('hello ' + name);\n}\n\n\u002F\u002F参数默认\nvar sayHello = function(name = 'world'){\n  console.log('hello ' + name);\n}\n\nsayHello() \u002F\u002F 'hello world'\nsayHello('ES6') \u002F\u002F 'hello ES6'\n"}]}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:a,value:"对于不定参数，以前都是对 arguments 对象处理，且 arguments 对象还是个伪数组，现在方便了："}]},{type:a,value:e},{type:b,tag:k,props:{className:[l]},children:[{type:b,tag:m,props:{className:[n,r]},children:[{type:b,tag:g,props:{},children:[{type:a,value:"var add = function(...arr){\n  console.log(arr.constructor.name) \u002F\u002F Array\n  return arr.reduce((a, b) =\u003E a+b, 0);\n}\nadd(1,2,3) \u002F\u002F 6\n"}]}]}]},{type:a,value:e},{type:b,tag:ad,props:{id:at},children:[{type:b,tag:t,props:{href:"#%E7%9B%B8%E5%85%B3%E9%93%BE%E6%8E%A5",ariaHidden:y,tabIndex:z},children:[{type:b,tag:c,props:{className:[A,B]},children:[]}]},{type:a,value:at}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:b,tag:t,props:{href:"https:\u002F\u002Fes6.ruanyifeng.com\u002F",rel:[T,U,V],target:W},children:[{type:a,value:"阮一峰ECMAScript6入门"}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:b,tag:t,props:{href:"https:\u002F\u002Fegghead.io\u002Fcourses\u002Flearn-es6-ecmascript-2015",rel:[T,U,V],target:W},children:[{type:a,value:"eegghead.io:learn-es6-ecmascript-2015"}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:b,tag:t,props:{href:bv,rel:[T,U,V],target:W},children:[{type:a,value:"es6，你不得不学"}]}]}]},excerpt:{type:bo,children:[{type:b,tag:h,props:{},children:[{type:a,value:bp},{type:b,tag:g,props:{},children:[{type:a,value:aj}]},{type:a,value:bq},{type:b,tag:g,props:{},children:[{type:a,value:aj}]},{type:a,value:br},{type:b,tag:t,props:{href:bs,rel:[T,U,V],target:W},children:[{type:a,value:aC}]}]},{type:a,value:e},{type:b,tag:h,props:{},children:[{type:b,tag:g,props:{},children:[{type:a,value:bt}]},{type:a,value:bu}]}]},dir:"\u002Ftech",path:"\u002Ftech\u002Fes6",extension:".md",updatedAt:"2020-12-03T15:41:42.126Z"},prev:{slug:bF,title:bF,path:"\u002Ftech\u002Fthis-in-javascript"},next:{slug:bG,title:bG,path:"\u002Ftech\u002Felectron-vue"},postId:al,tags:void 0}],fetch:[],mutations:[]}}("text","element","span","token","\n","punctuation","code","p"," ","function","div","nuxt-content-highlight","pre","line-numbers","operator","(",")","language-text","keyword","a",".","property-access",",",2,"true",-1,"icon","icon-link","console","method","message","this","{","}","string",3,"function-variable","=\u003E","var",":","h3","=","parameter","arrow","class-name","nofollow","noopener","noreferrer","_blank","handleMessage","receive","\n    ","info",1,"+",";","'Ben'","h2","language-js","\n        ","comment","class","原生构造函数的继承","ES6","foo","es6","静态方法","模块加载的实质","循环加载","字符串模版","一些其他核心功能","解构赋值","参数默认","相关链接","\n    name","\n    \n    "," handler","handler","\n\n    ","\"Hello \"","message ","name","请戳"," name","control-flow","return"," message ","\n\n","'Hi'"," arrowDeliveryBody ","\n ","\n\n arrowDeliveryBody","arguments","strong","arrow-function-》","Arrow Function =》",{},"关于-class-的继承","关于 class 的继承",{},"super-关键字","super 关键字",{},{},"module","Module",{},{},{},"let-const","let const",{},{},"promise-解决回掉","Promise 解决回掉",{},"for-of-与-","for of 与 ...",{},"set-集合和-map-结构","set 集合和 Map 结构",{},"root","现代浏览器基本都支持 "," 大部分特性，如果你想知道有哪些浏览器支持 "," 的特性，","https:\u002F\u002Fkangax.github.io\u002Fcompat-table\u002Fes6\u002F","Node"," 是 JavaScript 的服务器运行环境（runtime）。它对 ES6 的支持度更高。除了那些默认打开的功能，还有一些语法功能已经实现了，但是默认没有打开。","https:\u002F\u002Fsegmentfault.com\u002Fa\u002F1190000007817990","createGreeting","arrowGreeting","arrowGeetingToBen","new","number","1","。","window","命令、","this-in-javascript","electron-vue")));